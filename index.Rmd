---
title: "Ejercicio - Manejo de datos con R"
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
    df_print: paged
runtime: shiny_prerendered
description: >
  Assignment for Data Management in R module
---

```{r setup, include=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(learnr)
library(tidyverse)
library(randomNames)

set.seed(1)

farmer_data <- data.frame(
  id  = sample(1:100, size = 100),
  village_id = sample(1:8, size = 100, replace = TRUE),
  name = c(randomNames(50, gender = 0, which.names = "first"), randomNames(50, gender = 1, which.names = "first")),
  sex = c(sample(c("1", "M", "m", "Male"), 50, replace = TRUE), sample(c("2", "F", "f", "Female"), 50, replace = TRUE)),
  age = c(sample(seq(from = 18, to = 65, by = 1), 99, replace = TRUE), 180),
  hh_size = sample(c(1:10, -9), size = 100, replace = TRUE),
  income = sample(c(seq(from = 100, to = 900, by = 60), 0, -9), size = 100, replace = TRUE),
  costs = sample(c(seq(from = 50, to = 500, by = 20), -9), size = 100, replace = TRUE)
)

xx <- sample(1:100, 5)

for(i in 1:5){
  farmer_data$name[xx[i]] <- paste0(" ", farmer_data$name[xx[i]])
}

yy <- 1:100

yy <- yy[-xx]

yy <- sample(1:100, 5)

for(i in 1:5){
  farmer_data$name[yy[i]] <- paste0(farmer_data$name[yy[i]], " ")
}

plot_data <- data.frame(
  id = 1:300,
  farmer_id = sample(1:100, 300, replace = TRUE),
  area = sample(seq(from = 0.4, to = 8, by = 0.4), 300, replace = TRUE),
  pesticides = sample(0:1, 300, replace = TRUE),
  fertilisers = sample(0:1, 300, replace = TRUE)
)

plot_data <- plot_data%>%
  group_by(farmer_id)%>%
  mutate(plot_num = row_number())

plot_data <- pivot_wider(plot_data,
            id_cols = farmer_id,
            names_from = plot_num,
            values_from = c(id, area:fertilisers),
            names_sep = "_")

village_data <- data.frame(
  id = rep(c(1:8),3),
  name = rep(c("A","B","C","D","E","F","G","H"),3),
  information = c(rep("population", 8), rep("ngo_supported",8), rep("weight",8))
)

for(i in 1:nrow(village_data)){
  village_data$value[i] <- ifelse(
    village_data$information[i] == "population", sample(1500:10000,size = 1),
    ifelse(village_data$information[i] == "ngo_supported", sample(c("Yes", "No")), 
           sample(seq(0.02,1.98, by = 0.02)))
    )
}

farmer_data_additional <- data.frame(
  id  = 101:120,
  village_id = sample(1:8, size = 20, replace = TRUE),
  name = c(randomNames(10, gender = 0, which.names = "first"), randomNames(10, gender = 1, which.names = "first")),
  sex = c(rep("Male", 10), rep("Female", 10)),
  age = c(sample(seq(from = 18, to = 65, by = 1), 20, replace = TRUE)),
  hh_size = sample(1:10, size = 20, replace = TRUE),
  income = sample(c(seq(from = 100, to = 900, by = 60), 0), size = 20, replace = TRUE),
  costs = sample(seq(from = 50, to = 500, by = 20), size = 20, replace = TRUE)
)

farmer_data_additional$gross_income = farmer_data_additional$income - farmer_data_additional$costs

plot_data_additional <- data.frame(
  farmer_id = sample(101:120, size = 45, replace = TRUE),
  id = 301:345,
    area = sample(seq(from = 0.4, to = 8, by = 0.4), 45, replace = TRUE),
  pesticides = sample(0:1, 45, replace = TRUE),
  fertilisers = sample(0:1, 45, replace = TRUE)
)

plot_data_additional <- plot_data_additional%>%
  group_by(farmer_id)%>%
  mutate(plot_num = as.character(row_number()))%>%
  arrange(farmer_id, plot_num)

plot_data_long <-plot_data%>%
  pivot_longer(
    cols = id_1:fertilisers_8,
    names_to = c(".value", "plot_num"),
    names_sep = "_",
    values_drop_na = TRUE
  )

village_data_wide <- village_data%>%
  pivot_wider(
    names_from = information,
    values_from = value
  )

farmer_data_clean <- farmer_data%>%
  mutate(name = trimws(name, which = "both"),
         hh_size = na_if(hh_size, -9),
         income = na_if(income, -9),
         costs = na_if(costs, -9),
         sex = case_when(
    sex %in% c("Male", "m", "M", "1") ~ "Male",
    sex %in% c("Female", "f", "F", "2") ~ "Female"
  ),
  age = ifelse(age == 180, 18, age),
  gross_income = income-costs)%>%
  arrange(id)


farmer_data_full <- bind_rows(farmer_data_clean, farmer_data_additional)

plot_data_full <- bind_rows(plot_data_long, plot_data_additional)

plot_data_summary <- plot_data_full%>%
  group_by(farmer_id)%>%
  summarise(total_area = sum(area, na.rm = TRUE),
            nplots = n())

```

## Parte 1 - Limpieza de datos

### Conjunto de datos

Para empezar, trabajará con el siguiente conjunto de datos que contiene una serie de variables para una lista de 100 agricultores.

```{r, exercise = FALSE}
farmer_data
```

### Ejercicio 1a - Recortar los espacios en blanco

Comencemos por verificar si hay espacios en blanco, sospecho que puede haber algunos en nuestra columna del nombre.

Realicemos una verificación usando la función `únique` (unico) para ver todos los valores únicos para el nombre

```{r, exercise = FALSE}
unique(farmer_data$name)
```

Parece que nuestras sospechas eran correctas, tenemos alrededor de 10 valores para el nombre que tienen un espacio inicial o final de ellos.

Ejercicio 1a: usando `mutate` y `trimws`, elimine el espacio en blanco presente en la columna de nombre tanto al principio como al final de los valores de las variables

**RECUERDE** Puede inspeccionar los resultados de sus cambios en cualquier momento escribiendo el nombre del marco de datos (data frame) en el fragmento de código 

```{r ex1a, exercise = TRUE}
farmer_data <- farmer_data %>%
  mutate()

unique(farmer_data$name)
```

```{r ex1a-solution}
farmer_data <- farmer_data %>%
  mutate(name = trimws(name, which = "both"))

unique(farmer_data$name)
```

### Ejercicio 1b - Datos faltantes

Recuerde que en R necesitamos ser muy explícitos a la hora de definir datos. Los valores faltantes **DEBEN** ser codificados como `NA`

En nuestro conjunto de datos, lamentablemente no le hemos dicho a R explícitamente cuáles eran nuestros códigos de datos faltantes cuando importamos los datos. Por lo tanto, hay algunas variables que tienen algunos valores igual a -9. Sin embargo, este era un código para datos faltantes, pero R entenderá este valor como literalmente -9.

Veamos primero en qué variables tenemos este problema.

Ejercicio 1bi: use `summary` para verificar qué variables continuas en el conjunto de datos todavía usan el código de datos faltante `-9` en lugar de ser explícitamente `NA`. Tenga en cuenta que -9 será el valor mínimo en cada uno de estos casos.

```{r ex1bi, exercise = TRUE}


```

```{r ex1bi-solution}
summary(farmer_data)

farmer_data

# Debería haber encontrado que al menos 1 valor en cada una de las variables de hh_size, income y costs era igual a -9
```

Debería haber identificado algunas variables que estan usando este código.

Ejercicio 1bii: usando `mutate` y `na_if`, corrija las variables que todavia usan `-9` para que en su lugar se codifiquen como `NA`

**NOTA** Tome nota de cuántas variables necesita corregir durante esta pregunta. La respuesta formará parte del breve cuestionario de evaluación que se utilizará para inscribirlo en el certificado del módulo.

```{r ex1bii, exercise = TRUE}
farmer_data <- farmer_data %>%
  mutate()

summary(farmer_data)
```

```{r ex1bii-solution}
farmer_data <- farmer_data %>%
  mutate(hh_size = na_if(hh_size, -9),
         income = na_if(income, -9),
         costs = na_if(costs, -9))

summary(farmer_data)

# OR

farmer_data <- farmer_data %>%
  mutate_all(na_if, -9)

summary(farmer_data)

#Esto solo sería útil si -9 SIEMPRE será un código para valores faltantes y NUNCA un valor verdadero de una variable

#Se recomienda mirar en mutate_at o mutate_if para ver cómo puede hacer la misma edición en varias columnas, pero no en todas.

```

### Ejercicio 1c - Corrección de etiquetas

Algo más se veía mal en nuestra variable sexo. Usemos `unique` para echar un vistazo a todos los valores únicos del sexo.

```{r, exercise = FALSE}
unique(farmer_data$sex)
```

Hmm, lamentablemente parece que tenemos múltiples valores para lo mismo. Hombre y Mujer han sido codificados de cuatro maneras diferentes cada uno.

Ejercicio 1c: Usando `mutate` y `case_when`, estandarice la variable sexo de tal manera que

Male, m, M y "1" se recodifican como "Male"

Female, f, F y "2" se recodifican como "Female"

**Pista** Piense en cómo usamos el operador `%in%`

```{r ex1c, exercise = TRUE}
farmer_data <- farmer_data %>%
  mutate()
```

```{r ex1c-solution}
farmer_data <- farmer_data %>%
  mutate(sex = case_when(
    sex %in% c("Male", "m", "M", "1") ~ "Male",
    sex %in% c("Female", "f", "F", "2") ~ "Female"
  ))

table(farmer_data$sex)
```

### Ejercicio 1d - Corrección de valores atípicos

Usemos un histograma para inspeccionar una de nuestras variables continuas en busca de posibles errores de entrada de datos

```{r}
hist(farmer_data$age)
```

Parece que tenemos un valor atípico inverosímilmente alto para la edad.

Al ponerse en contacto con el enumerador que recopiló los datos de este agricultor, descubre que el valor real era 18 años. Simplemente se ingresó incorrectamente.

Ejercicio 1d: usando cualquier método mostrado en el libro de trabajo, corrija este valor inverosímilmente alto de 180 años al valor correcto de 18 años.

```{r ex1d, exercise = TRUE}

```

Recuerde que puede usar el histograma para graficar el valor y verificar sus cambios

```{r ex1db, exercise = TRUE}
hist(farmer_data$age)
```

```{r ex1d-solution}
farmer_data$age[farmer_data$age == 180] <- 19

#OR

farmer_data <- farmer_data%>%
  mutate(age = ifelse(age == 180, 18, age))
``` 

### Ejercicio 1e - Crear una nueva variable

Como parte del plan de análisis de datos, se puede ver que parte del análisis incluirá una evaluación de los ingresos brutos de los agricultores, un cálculo de los ingresos menos los costos. Sin embargo, descubre que esto no se calculó directamente como parte de la recopilación de datos.

Ejercicio 1e: usando `mutate` cree una nueva variable llamada `gross_income` que es el ingreso menos los costos.

```{r ex1e, exercise = TRUE}

```

```{r ex1e-solution}
farmer_data <- farmer_data%>%
  mutate(gross_income = income-costs)

farmer_data$gross_income
```

### Ejercicio 1f - Clasificación de datos

Finalmente, es posible que haya notado que actualmente no hay un orden particular para nuestros datos. Si bien no es obligatorio, ordenar los datos puede ser útil para la presentación, la legibilidad y ayudar a los usuarios a encontrar fácilmente cierta información.

Tenemos una variable de clasificación natural en nuestro identificador único "id"

Ejercicio 1f: Usando `arrange`, ordene los datos usando la variable id para que las filas estén en orden del 1 al 100 por id.

```{r ex1f, exercise = TRUE}

```

```{r ex1f-solution}
farmer_data <- farmer_data%>%
  arrange(id)
```

```{r, echo = FALSE}
farmer_data <- farmer_data%>%
  mutate(name = trimws(name, which = "both"),
         hh_size = na_if(hh_size, -9),
         income = na_if(income, -9),
         costs = na_if(costs, -9),
         sex = case_when(
    sex %in% c("Male", "m", "M", "1") ~ "Male",
    sex %in% c("Female", "f", "F", "2") ~ "Female"
  ),
  age = ifelse(age == 180, 18, age),
  gross_income = income-costs)%>%
  arrange(id)
```

## Parte 2: Remodelación de los datos

### Conjuntos de datos

Antes de probar sus habilidades para pivotar datos, veamos algunos datos adicionales que tenemos para este proyecto. Son datos al nivel de parcela, mientras que nuestro conjunto de datos anterior estaba a nivel del agricultor.

Cada agricultor puede tener hasta 8 parcelas, están etiquetadas como id_1, id_2 y así sucesivamente. Notará que muchos de los valores en estas columnas son NA ya que no todos los agricultores tienen tantas parcelas.

```{r}
plot_data
```

En segundo lugar, una fuente externa le ha proporcionado algunos datos sobre los municipios que se han utilizado en este proyecto. Sin embargo, lamentablemente se ha transmitido en formato largo con filas individuales para la población de municipios, los pesos de muestreo y si recibieron o no apoyo de una ONG.

```{r}
village_data
```

### Ejercicio 2a - Pivote a datos en formato largo

En primer lugar, pongamos los datos de parcela en una forma más útil. Al realizar un análisis, será mucho más sencillo mantener información comparable en la misma columna. Es decir, mantener todos los valores para el área de la parcela en una sola columna.

Ejercicio 2a: usando `pivot_longer` remodele los datos en formato ancho de la parcela en un nuevo conjunto de datos largos, guarde esta salida como `plot_data_long` y llame a la nueva variable, que mostrará el número de parcela dentro de un agricultor, "plot_num".

Incluya el argumento `values_drop_na = TRUE` en su respuesta. Esto evitará que se creen filas innecesarias donde todas las variables serán `NA`. En otras palabras, solo tendremos para cada agricultor tantas lineas de datos como parcelas tenga.

**Sugerencia**: si se queda atascado, vuelva a consultar el libro de trabajo de la sesión 2 y cómo utilizamos la cadena especial `".value"`.

**NOTA** Para los siguientes pasos, puede usar `dim()` para verificar la cantidad de filas y columnas en sus datos y asi asegurarse de tener la cantidad correcta. Tome nota de cuántas filas hay en el marco de datos resultante. La respuesta formará parte del breve cuestionario de evaluación que se utilizará para inscribirlo en el certificado del módulo.

```{r ex2a, exercise = TRUE}
plot_data_long <-plot_data%>%
  pivot_longer(
    values_drop_na = TRUE
  )
```

```{r ex2a-solution}
plot_data_long <-plot_data%>%
  pivot_longer(
    cols = id_1:fertilisers_8,
    names_to = c(".value", "plot_num"),
    names_sep = "_",
    values_drop_na = TRUE
  )

plot_data_long

dim(plot_data_long)
```


### Ejercicio 2b - Pivote a datos en formato ancho

A continuación, hagamos lo contrario con los datos de ese municipio.

Ejercicio 2b: usando `pivot_wider`, transforme los datos en formato ancho de modo que solo tenga una fila por municipio. Guarde estos datos en un nuevo objeto con nombre `village_data_wide`


```{r ex2b, exercise = TRUE}
village_data_wide <- village_data%>%
  pivot_wider()
```

```{r ex2b-solution}
village_data_wide <- village_data%>%
  pivot_wider(
    names_from = information,
    values_from = value
  )

village_data_wide

dim(village_data_wide)
```

## Parte 3 - Unión de datos

### Conjuntos de datos

Para el primer ejercicio de esta sección final, uniremos nuestros conjuntos de datos anteriores con algunas observaciones adicionales sobre nuestros agricultores y parcelas. 20 nuevos agricultores con 45 parcelas entre todos ellos.

```{r}
farmer_data_additional
```

```{r}
plot_data_additional
```

### Ejercicio 3a - Union de conjuntos de datos

Los conjuntos de datos adicionales utilizan los mismos formatos que hemos desarrollado a partir de nuestros datos ordenados. Podemos pasar directamente a agregarlos a nuestros marcos de datos existentes.

Ejercicio 3a: usando `bind_rows`, agregue las nuevas observaciones a farmer_data y plot_data_long.

**NOTA**: La versión limpia de los datos del agricultor se guardó en un nuevo objeto llamado `farmer_data_clean`. Utilice este conjunto de datos en lugar de `farmer_data`

**NOTA** Para los siguientes pasos, puede usar `dim()` para verificar la cantidad de filas y columnas en sus datos para asegurarse de tener la cantidad correcta. Tome nota de cuántas filas hay en el conjunto de datos `farmer_data_full`. La respuesta formará parte del breve cuestionario de evaluación que se utilizará para inscribirlo en el certificado del módulo.

```{r ex3a, exercise = TRUE}
farmer_data_full <- 
  
plot_data_full

dim(plot_data_full)

dim(farmer_data_full)
```

```{r ex3a-solution}
farmer_data_full <- bind_rows(farmer_data_clean, farmer_data_additional)

plot_data_full <- bind_rows(plot_data_long, plot_data_additional)

dim(plot_data_full)

dim(farmer_data_full)
```

### Ejercicio 3b - Resumen de los datos

Ahora pasaremos a resumir primero algunos datos de un nivel inferior para luego unirlos con datos de un nivel superior.

Como parte de nuestro plan de análisis de datos, necesitamos el área total de las fincas por agricultor, que es la suma de las áreas de las parcelas individuales de cada agricultor individual. Queremos luego fusionar esto con nuestro conjunto de datos de agricultores.
 
Ejercicio 3b: usando `group_by` y `summarise`, cree un nuevo conjunto de datos que sea un resumen de los datos a nivel de parcela. Dele el nombre de `plot_data_summary`. Cree variables de resumen para el área total de las parcelas de un agricultor utilizando `sum` y luego cree también una variable que cuente el número de parcelas que posee un agricultor.

```{r ex3b, exercise = TRUE}
plot_data_summary <- plot_data_full%>%
```

```{r ex3b-solution}
plot_data_summary <- plot_data_full%>%
  group_by(farmer_id)%>%
  summarise(total_area = sum(area, na.rm = TRUE),
            nplots = n())

plot_data_summary
```

### Ejercicio 3c - Fusión de datos

Fusione el conjunto de datos plot_data_summary con el conjunto de datos farmer_data_full. Ahora tenemos algunos agricultores de los que no tenemos datos de parcela disponibles. Hemos tomado la decisión para el análisis de que solo queremos agricultores que posean al menos una parcela.

Ejercicio 3c: Usando un tipo de fusión que solo mantendrá a los agricultores que tienen datos de parcela con los que se la pueda relacionar, fusione plot_data_summary con farmer_data_full.

**SUGERENCIA** Recuerda que puede usar `c()` para unir variables donde tienen nombres diferentes en los dos conjuntos de datos

```{r ex3c, exercise = TRUE}
farmer_data_full <- 
```

```{r ex3c-solution}
farmer_data_full <- inner_join(
  farmer_data_full, plot_data_summary, by = c("id" = "farmer_id")
)
```

Gracias por completar esta tarea.

Ahora vaya al cuestionario del Módulo 3, donde se le harán un par de preguntas sobre la tarea. Este cuestionario se utilizará para indicar la finalización del módulo. Una vez que haya completado el cuestionario, puede esperar recibir su certificado dentro de unos días hábiles.

